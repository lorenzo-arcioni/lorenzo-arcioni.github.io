<!DOCTYPE html>
<html lang="en">
<head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VF7D8E2FE3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VF7D8E2FE3');
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="../../../fav-icon.png">
    <link rel="stylesheet" href="../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="../../../scripts.js" defer></script>

    <script>
        MathJax = {
          tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

    <style type="text/css">

        p {
            font-size: 20px;
        }

        h3 {
            font-size: 23px;
        }

        h2 {
            font-size: 26px;
        }
        h4 {
            font-size: 22px;
        }
        code {
            font-size: 20px;
            background-color: #1f1f1e;
        }
        ol,ul {
            font-size: 20px;
            margin-left: 40px;
        }
        pre {
            background-color: #1f1f1e;
        }
    </style>

    <title>Lorenzo Arcioni</title>
</head>

<body>
    <header>
        <nav>
            <div class="container">
                <div class="profile">
                    <img src="../../../lorenzoarcioni.png" alt="Immagine del profilo" class="profile-img">
                    <div class="name">
                        <h1 style="font-size: 32px;">Lorenzo Arcioni</h1>
                        <p class="subtitle" style="font-size: 20px;">Machine Learning Engineer | Data Scientist</p>
                        <p class="mobile_subtitle" style="font-size: 20px;">Machine Learning Engineer<br><br>Data Scientist</p>
                        <div class="social">
                            <a href="https://www.linkedin.com/in/lorenzo-arcioni-216b921b5/" target="_blank"><i class="fa fa-linkedin"></i></a>
                            <a href="https://github.com/lorenzo-arcioni" target="_blank"><i class="fa fa-github"></i></a>
                            <a href="https://www.kaggle.com/lorenzoarcioni" target="_blank"><strong>K</strong></a>
                            <a href="https://www.instagram.com/lorenzo_arcioni/" target="_blank"><i class="fa fa-instagram"></i></a>
                            <a href="https://medium.com/@lorenzo.arcioni2000/" target="_blank"><i class="fa fa-medium"></i></a>
                        </div>
                    </div>
                    <div class="blog-link"><p><a href="../../../index.html"><u>Home</u></a></p></div>
                </div>
                <hr>
            </div>
        </nav>
    </header>

    <main>
        <div class="container">
            <h2>Algoritmo di Crittografia RSA</h2>
            <p>L'algoritmo RSA è un metodo di crittografia a chiave pubblica ampiamente utilizzato che garantisce la trasmissione sicura dei dati. Si basa sulle proprietà matematiche dei grandi numeri primi e sulla difficoltà di fattorizzare il loro prodotto.</p>
            <br>
            <h3>Descrizione dell'Algoritmo</h3>
            <p>L'algoritmo RSA può essere descritto utilizzando i seguenti passaggi:</p>
            <br>
            <ol style="margin-left:40px;">
                <li>Selezionare due numeri primi distinti \(p\) e \(q\).</li>
                <li>Calcolare \(n = pq\). \(n\) viene utilizzato come modulo sia per la chiave pubblica che per quella privata.</li>
                <li>Calcolare il totiente \(\phi(n) = (p-1)(q-1)\).</li>
                <li>Scegliere un intero \(e\) tale che \(1 < e < \phi(n)\) e \(e\) sia coprimo con \(\phi(n)\).</li>
                <li>Determinare \(d\) come inverso moltiplicativo modulo di \(e\) modulo \(\phi(n)\). In altre parole, \(d\) soddisfa l'equazione \(de \equiv 1 \mod \phi(n)\).</li>
                <li>La chiave pubblica è \((e, n)\) e la chiave privata è \((d, n)\).</li>
                <li>Per crittografare un messaggio \(m\), calcolare il testo cifrato \(c \equiv m^e \mod n\).</li>
                <li>Per decrittografare il testo cifrato \(c\), calcolare il messaggio originale \(m \equiv c^d \mod n\).</li>
            </ol>
            <br>
            <h3>Rappresentazione Matematica</h3>
            <p>L'algoritmo RSA può essere rappresentato matematicamente come segue:</p>
            <br>
            <p>
                \[
                \begin{aligned}
                &\text{Generazione della chiave:} \\
                &\text{1. Selezionare i numeri primi } p \text{ e } q \\
                &\text{2. Calcolare } n = pq \\
                &\text{3. Calcolare } \phi(n) = (p-1)(q-1) \\
                &\text{4. Scegliere } e \text{ tale che } 1 < e < \phi(n) \text{ e } \gcd(e, \phi(n)) = 1 \\
                &\text{5. Calcolare } d \text{ tale che } de \equiv 1 \mod \phi(n) \\
                &\text{Chiave pubblica: } (e, n) \\
                &\text{Chiave privata: } (d, n) \\
                &\text{Crittografia: } c \equiv m^e \mod n \\
                &\text{Decrittografia: } m \equiv c^d \mod n \\
                \end{aligned}
                \]
            </p>

            <h3>Esempio</h3>
            <p>Criptiamo e decriptaimo un messaggio usando l'algoritmo RSA:</p>
            <br>
            <ol style="margin-left:40px;">
                <li>Scegliere due numeri primi \(p = 61\) e \(q = 53\).</li>
                <li>Calcolare \(n = pq = 61 \times 53 = 3233\).</li>
                <li>Calcolare il totiente \(\phi(n) = (61-1)(53-1) = 3120\).</li>
                <li>Scegliere \(e = 17\) tale che \(1 < 17 < 3120\) e \(\gcd(17, 3120) = 1\).</li>
                <li>Determinare \(d = 2753\) tale che \(17 \times 2753 \equiv 1 \mod 3120\).</li>
                <li>La chiave pubblica è \((17, 3233)\) e la chiave privata è \((2753, 3233)\).</li>
                <li>Per crittografare un messaggio \(m = 65\), calcolare il testo cifrato \(c = 65^{17} \mod 3233 = 2790\).</li>
                <li>Per decrittografare il testo cifrato \(c = 2790\), calcolare il messaggio originale \(m = 2790^{2753} \mod 3233 = 65\).</li>
            </ol>
            <br>
            <hr>
            <br>
            <h3>Comprensione dell'Algoritmo RSA</h3>
            <p>L'algoritmo RSA si basa su diverse proprietà matematiche:</p>
            <br>
            <ul>
                <li>Fattorizzazione dei Primi: La difficoltà di fattorizzare un numero grande \(n\) nei suoi componenti primi \(p\) e \(q\) garantisce la sicurezza dell'algoritmo RSA.</li>
                <li>Aritmetica Modulare: L'algoritmo si basa fortemente sulle proprietà dell'aritmetica modulare, in particolare l'esponenziazione modulare e gli inversi moltiplicativi modulari.</li>
                <li>Selezione dei Coprimi: Scegliere \(e\) tale che \(\gcd(e, \phi(n)) = 1\) garantisce che \(e\) abbia un inverso moltiplicativo modulo \(d\).</li>
            </ul>
            <br>
            <p>Queste proprietà rendono RSA un algoritmo robusto per la comunicazione sicura.</p>
            <br>
            <h4>Dimostrazioni</h4>
            <p>Possiamo dimostrare la correttezza dell'algoritmo attraverso le seguenti dimostrazioni:</p>
            <br>
            <ul>
                <li><strong>Dimostrazione che \(de \equiv 1 \mod \phi(n)\)</strong>: Poiché \(d\) è scelto come l'inverso moltiplicativo modulo di \(e\) modulo \(\phi(n)\), soddisfa l'equazione \(de = k\phi(n) + 1\) per qualche intero \(k\). Quindi, \(de \equiv 1 \mod \phi(n)\). \(\square\)</li>
                <br>
                <li><strong>Dimostrazione che \(m \equiv (m^e)^d \mod n\)</strong>:<br><br>
                    <p>Secondo il teorema di Eulero, se \(m\) è coprimo con \(n\), allora \(m^{\phi(n)} \equiv 1 \mod n\). Poiché \(de = k\phi(n) + 1\), abbiamo:</p>
                    <br>
                    <p>\(m^{de} = m^{k\phi(n) + 1} = (m^{\phi(n)})^k \cdot m \equiv 1^k \cdot m \equiv m \mod n\). Quindi, \(m \equiv (m^e)^d \mod n\). \(\square\)</p>
                </li>
            </ul>
            <br>
            <p>Ora che abbiamo dimostrato la validità dell'algoritmo, dobbiamo dimostrare che l'algoritmo termina in un numero finito di passaggi.</p>
            <br>
            <ul>
                <li><strong>Dimostrazione che l'algoritmo termina in un numero finito di passaggi</strong>:
                    <br>
                    <br>
                    <p>Dato che l'esponenziazione modulare e l'algoritmo di Euclide per trovare \(d\) operano entrambi in tempo polinomiale, l'algoritmo RSA termina in un numero finito di passaggi. \(\square\)</p>
                </li>
            </ul>
            <br>
            <p>L'algoritmo RSA è uno dei metodi di crittografia più sicuri e ampiamente utilizzati. Garantisce la riservatezza e l'integrità dei dati in varie applicazioni, tra cui le comunicazioni sicure e le firme digitali.</p>
            <br>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 Lorenzo Arcioni. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>