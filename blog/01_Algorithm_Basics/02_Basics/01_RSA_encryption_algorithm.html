<!DOCTYPE html>
<html lang="en">
<head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VF7D8E2FE3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VF7D8E2FE3');
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="../../../fav-icon.png">
    <link rel="stylesheet" href="../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="../../../scripts.js" defer></script>

    <script>
        MathJax = {
          tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

    <style type="text/css">

        p {
            font-size: 20px;
        }

        h3 {
            font-size: 23px;
        }

        h2 {
            font-size: 26px;
        }
        h4 {
            font-size: 22px;
        }
        code {
            font-size: 20px;
            background-color: #1f1f1e;
        }
        ol,ul {
            font-size: 20px;
            margin-left: 40px;
        }
        pre {
            background-color: #1f1f1e;
        }
    </style>

    <title>Lorenzo Arcioni</title>
</head>

<body>
    <header>
        <nav>
            <div class="container">
                <div class="profile">
                    <img src="../../../lorenzoarcioni.jpg" alt="Immagine del profilo" class="profile-img">
                    <div class="name">
                        <h1 style="font-size: 32px;">Lorenzo Arcioni</h1>
                        <p class="subtitle" style="font-size: 20px;">Machine Learning Engineer | Data Scientist</p>
                        <p class="mobile_subtitle" style="font-size: 20px;">Machine Learning Engineer<br><br>Data Scientist</p>
                        <div class="social">
                            <a href="https://www.linkedin.com/in/lorenzo-arcioni-216b921b5/" target="_blank"><i class="fa fa-linkedin"></i></a>
                            <a href="https://github.com/lorenzo-arcioni" target="_blank"><i class="fa fa-github"></i></a>
                            <a href="https://www.kaggle.com/lorenzoarcioni" target="_blank"><strong>K</strong></a>
                            <a href="https://www.instagram.com/lorenzo_arcioni/" target="_blank"><i class="fa fa-instagram"></i></a>
                            <a href="https://medium.com/@lorenzo.arcioni2000/" target="_blank"><i class="fa fa-medium"></i></a>
                        </div>
                    </div>
                    <div class="blog-link"><p><a href="../../../index.html"><u>Home</u></a></p></div>
                </div>
                <hr>
            </div>
        </nav>
    </header>

    <main>
        <div class="container">
            <h2>RSA Encryption Algorithm</h2>
            <p>The RSA algorithm is a widely used public-key cryptography method that ensures secure data transmission. It relies on the mathematical properties of large prime numbers and the difficulty of factorizing their product.</p>
            <br>
            <h3>Algorithm Description</h3>
            <p>The RSA algorithm can be described using the following steps:</p>
            <br>
            <ol style="margin-left:40px;">
                <li>Select two distinct prime numbers \(p\) and \(q\).</li>
                <li>Compute \(n = pq\). \(n\) is used as the modulus for both the public and private keys.</li>
                <li>Calculate the totient \(\phi(n) = (p-1)(q-1)\).</li>
                <li>Choose an integer \(e\) such that \(1 < e < \phi(n)\) and \(e\) is coprime with \(\phi(n)\).</li>
                <li>Determine \(d\) as the modular multiplicative inverse of \(e\) modulo \(\phi(n)\). In other words, \(d\) satisfies the equation \(de \equiv 1 \mod \phi(n)\).</li>
                <li>The public key is \((e, n)\) and the private key is \((d, n)\).</li>
                <li>To encrypt a message \(m\), compute the ciphertext \(c \equiv m^e \mod n\).</li>
                <li>To decrypt the ciphertext \(c\), compute the original message \(m \equiv c^d \mod n\).</li>
            </ol>
            <br>
            <h3>Mathematical Representation</h3>
            <p>The RSA algorithm can be mathematically represented as:</p>
            <br>
            <p>
                \[
                \begin{aligned}
                &\text{Key generation:} \\
                &\text{1. Select primes } p \text{ and } q \\
                &\text{2. Compute } n = pq \\
                &\text{3. Calculate } \phi(n) = (p-1)(q-1) \\
                &\text{4. Choose } e \text{ such that } 1 < e < \phi(n) \text{ and } \gcd(e, \phi(n)) = 1 \\
                &\text{5. Compute } d \text{ such that } de \equiv 1 \mod \phi(n) \\
                &\text{Public key: } (e, n) \\
                &\text{Private key: } (d, n) \\
                &\text{Encryption: } c \equiv m^e \mod n \\
                &\text{Decryption: } m \equiv c^d \mod n \\
                \end{aligned}
                \]
            </p>

            <h3>Example</h3>
            <p>Let's encrypt and decrypt a message using the RSA algorithm:</p>
            <br>
            <ol style="margin-left:40px;">
                <li>Choose two prime numbers \(p = 61\) and \(q = 53\).</li>
                <li>Compute \(n = pq = 61 \times 53 = 3233\).</li>
                <li>Calculate the totient \(\phi(n) = (61-1)(53-1) = 3120\).</li>
                <li>Choose \(e = 17\) such that \(1 < 17 < 3120\) and \(\gcd(17, 3120) = 1\).</li>
                <li>Determine \(d = 2753\) such that \(17 \times 2753 \equiv 1 \mod 3120\).</li>
                <li>The public key is \((17, 3233)\) and the private key is \((2753, 3233)\).</li>
                <li>To encrypt a message \(m = 65\), compute the ciphertext \(c = 65^{17} \mod 3233 = 2790\).</li>
                <li>To decrypt the ciphertext \(c = 2790\), compute the original message \(m = 2790^{2753} \mod 3233 = 65\).</li>
            </ol>
            <br>
            <hr>
            <br>
            <h3>Understanding the RSA Algorithm</h3>
            <p>The RSA Algorithm is based on several mathematical properties:</p>
            <br>
            <ul>
                <li>Prime Factorization: The difficulty of factorizing a large number \(n\) into its prime components \(p\) and \(q\) ensures the security of the RSA algorithm.</li>
                <li>Modular Arithmetic: The algorithm heavily relies on properties of modular arithmetic, especially modular exponentiation and modular multiplicative inverses.</li>
                <li>Coprime Selection: Choosing \(e\) such that \(\gcd(e, \phi(n)) = 1\) ensures that \(e\) has a modular multiplicative inverse \(d\).</li>
            </ul>
            <br>
            <p>These properties make RSA a robust algorithm for secure communication.</p>
            <br>
            <h4>Proofs</h4>
            <p>We can demonstrate the correctness of the algorithm through proofs:</p>
            <br>
            <ul>
                <li><strong>Proof that \(de \equiv 1 \mod \phi(n)\)</strong>: Since \(d\) is chosen as the modular multiplicative inverse of \(e\) modulo \(\phi(n)\), it satisfies the equation \(de = k\phi(n) + 1\) for some integer \(k\). Thus, \(de \equiv 1 \mod \phi(n)\). \(\square\)</li>
                <br>
                <li><strong>Proof that \(m \equiv (m^e)^d \mod n\)</strong>:<br><br>
                    <p>By Euler's theorem, if \(m\) is coprime to \(n\), then \(m^{\phi(n)} \equiv 1 \mod n\). Since \(de = k\phi(n) + 1\), we have:</p>
                    <br>
                    <p>\(m^{de} = m^{k\phi(n) + 1} = (m^{\phi(n)})^k \cdot m \equiv 1^k \cdot m \equiv m \mod n\). Thus, \(m \equiv (m^e)^d \mod n\). \(\square\)</p>
                </li>
            </ul>
            <br>
            <p>Now that we have demonstrated the validity of the algorithm, we must demonstrate that the algorithm finishes in a finite number of steps.</p>
            <br>
            <ul>
                <li><strong>Proof that the algorithm finishes in a finite number of steps</strong>:
                    <br>
                    <br>
                    <p>Given that modular exponentiation and the Euclidean algorithm for finding \(d\) both operate in polynomial time, the RSA algorithm finishes in a finite number of steps. \(\square\)</p>
                </li>
            </ul>
            <br>
            <p>The RSA algorithm is one of the most secure and widely used encryption methods. It ensures the confidentiality and integrity of data in various applications, including secure communications and digital signatures.</p>
            <br>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 Lorenzo Arcioni. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>